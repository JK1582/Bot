#*This is a document to help the IT team troubleshoot problems with the chatbot in the future.*

##**Troubleshooting**

If the bot suddenly stops working, try checking the following:
1. The Microsoft App ID and Password match between the pipeline and Azure. You can confirm this by double-checking the Microsoft App ID / PW in the bot channels registration on portal.azure.com
versus the ones in the appsettings.json. **Note: the Microsoft PW is only valid for 6 months at a time, so this will have to be regenerated in that interval**
2. Check the credit remaining on the Azure resource for the bot. A bot costs about $50 a month, and if it runs out of money it will stop working.
3. Check LUIS and SharePoint - make sure both are up and running and none of the lists on SharePoint have been deleted.


##**Development**

This is a good place to start if you're looking to add features to the bot.

All interactions with the user start in the MEMICBot.cs file. This includes two overloaded methods:

1. `OnMessageActivityAsync()` is called whenever the end user sends a message in the chat. It takes a TurnContext in as an argument which contains information about the users message.
This can include things like the text (accessed via turnContext.Activity.text), the users ID, and attachments.
2. `OnMembersAddedAsync()` is called when a user joins the chat. It is generally used for startng the conversation. **This one can be a little tricky**. In some cases, this is called when the user opens the bot. For example, in a webchat
like MyMEMIC, this is called before a single message is sent. However, in other platforms like WebEx Teams, this isn't called until the end user sends the first message. Thus, currently
the bot checks if it is in a web chat before sending a greeting message. This is to avoid it sending a greeting message AFTER the user types their first message.

Most of the bot's functionality comes from the `OnMessageActivityAsync()` method. It makes a call to `LUIntentionHandler` to determine the intent of the user. LU in this case just means
language understanding (using Microsoft LUIS at the moment). LUIntentionHandler takes into account what the language understanding tool thinks the intent of the user is, as well
as whether or not the user was asked a question. There's a small little flowchart that eventually leads to the response.

The intent from the LU is determined by a call to `HR_API.GetLanguageUnderstandingResponse()`. This returns an "intent" that the AI thinks the user is asking about.

From there, the functionality splits into two different routes. If the intent is one of the ones in SharePoint (those are grabbed by an api call to `HR_API.GetCustomHRResponses()`), 
it will return the response found there. Otherwise, if it is one of the responses that is constantly changing, like "when is the next holiday", it will branch out to that class
and grab the response from there.

##**A note about member variables of classes in the bot framework**
If you're looking to store data about the conversation, you might run into the following issue:
1. Non-static member variables of the MEMICBot (or any other bot you create) get reset with every message. For example, if I store the previous message in a `private string prevMessage` 
member variable, it will be reset to its default value after the next message is sent.
2. Static member variables don't get reset, but they can be affected by other conversations. For example, if I store my previous message in a `private static string prevMessage`
member variable, other conversations with the bot by other users will be able to change MY `prevMessage` variable. This is because each instance of the bot functions as a seperate 
thread, so they share static variables.

The solution to this is to use a [ConcurrentDictionary](https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentdictionary-2?view=net-5.0). 
The key is the user's ID (a unique value generated by the bot, per user.) which can be accessed with `turnContext.Activity.From.Id` and
 the value is whatever data you want to store. I also store the DateTime that the key was last accessed at so I can clean up the dictionary as I go along (removing old users).

 ##**Testing your changes**
 Once you have implemented your changes, you want to test them locally before you push them to Azure. The [Bot Framework Emulator](https://github.com/microsoft/BotFramework-Emulator)
  is a great place to do this. However, because most of the appsettings are put in place by the pipeline, you'll need to modify your app settings locally to test it there. 
  
An appsettings with the correct values can be found in the repo under `appsettings_copy.json`. 

You'll notice that the Microsoft App ID and PW are **not filled in**. This is intentional - the Emulator doesn't work if they are filled in locally.

##**Publishing**
Once you've tested your changes, simply updating the master branch will publish your bot to Azure using the pipeline. Should it fail, the pipeline tab in ADO will tell you what went wrong.